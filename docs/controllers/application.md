# The Application

The controller **application** watches **object** changes and forwards the main **object** to the reconciler.

This doc is a **WIP**.

## Plan

this document should describe what we plan on describing (super simple pod controller), how to glue it together
while it's in the main 3 documents, it needs to be an overview doucment (as it contains the other two in some sense)

should link to sub-sections where we take shortcuts here (different objects, related objects, controller options, packaging)

## Project Setup

```sh
cargo new --bin ctrl
cd ctrl
```

add the following lines to your `[dependencies]` in your `Cargo.toml`:

```toml
kube = { version = "0.69.1", features = ["runtime", "client", "derive"] }
k8s-openapi = { version = "0.14.0", features = ["v1_22"]}
```

The `k8s-openapi` dependency is not always necessary, but we will be using [Pod] as our controlled [[object]], so we will need it here.

TODO: discuss peripheral dependencies; `tokio`, `futures` (for main + .for_each), `serde` (if making api calls)

### Import the object

Import the object that you want to control into your `main.rs`.

For the purposes of this demo we are going to use [Pod], and because we don't want to control all pods, we will limit to pods with our own `category: weird` label using [ListParams].

```rust
use k8s_openapi::api::core::v1::Pod;
let params = ListParams::default().labels("category=weird");
```

### Seting up the controller

This is where we will start defining our `main` and glue everything together:

```rust
#[tokio::main]
async fn main() -> Result<()> {
    let client = Client::try_default().await?;
    let pods = Api::<Pod>::all(client);
    let params = ListParams::default().labels("category=weird");

    Controller::new(pods.clone(), params)
        .run(reconcile, error_policy, Context::new(Data { pods }))
        .for_each(|_| futures::future::ready(()))
        .await;

    Ok(())
}
```

This creates a [Client], a Pod [Api] object, and a [Controller] for the subset of pods defined by the [ListParams].

Because there are no related objects, we merely tell the controller to call reconcile when any pods in our subset changes.

### Creating the reconciler

We will start with a noop `reconcile` fn
```rust
async fn reconcile(object: Arc<Pod>, data: Context<Data>) ->
    Result<ReconcilerAction, Error>
{
    let pods = ctx.get_ref().pods.clone();
    // object.annotations_mut(). TODO: edit annotations
    // TODO: save via entry api?
    // Done.

    Ok(ReconcilerAction {
        requeue_after: Some(Duration::from_secs(3600 / 2)),
    })
}
```

and a `noop` error handler:

```rust
fn error_policy(_error: &Error, _ctx: Context<Data>) -> ReconcilerAction {
    ReconcilerAction {
        requeue_after: Some(Duration::from_secs(5)),
    }
}
```

TODO: discuss saving triggering reconciles

## Deploying

### Containerising

Options:

- rust official image as multi-stage builder
- musl + distroless

TODO: caching caveats (links only)

### Developing

TODO: dev workflow via `k3d` + `tilt` or straight `cargo run` possibilities via `Client::try_default`

### CI

TODO:

- clippy
- docker build with cache

--8<-- "includes/abbreviations.md"
--8<-- "includes/links.md"

[//begin]: # "Autogenerated link references for markdown compatibility"
[object]: object "The Object"
[//end]: # "Autogenerated link references"
